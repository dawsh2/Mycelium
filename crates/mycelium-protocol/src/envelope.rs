use crate::message::Message;
use crate::routing::{CorrelationId, Destination, TraceId};
use std::any::Any;
use std::sync::Arc;
use thiserror::Error;

/// Default schema ID for Mycelium protocol
///
/// This is a placeholder. In production, you should set your own unique schema ID
/// in your contracts.yaml and have codegen generate this constant.
pub const DEFAULT_SCHEMA_ID: u32 = 0x4D59_4345; // "MYCE" in ASCII

/// Default schema version
///
/// Increment this when making breaking changes to your message protocol.
/// Should be set in contracts.yaml and generated by codegen.
pub const DEFAULT_SCHEMA_VERSION: u16 = 1;

/// Error types for envelope operations
#[derive(Error, Debug)]
pub enum EnvelopeError {
    #[error("Type mismatch: expected type {expected}, got type {got}")]
    TypeMismatch { expected: u16, got: u16 },

    #[error("Downcast failed: message is not of the expected type")]
    DowncastFailed,
}

/// Message envelope containing type information and payload
///
/// Envelopes allow type-erased message passing while preserving
/// type safety through downcasting.
///
/// ## Performance Notes
///
/// - `topic` uses `Arc<str>` for zero-cost cloning (important for broadcast patterns)
/// - `payload` uses `Arc<dyn Any>` for zero-copy message sharing across subscribers
///
/// ## Schema Evolution
///
/// - `schema_id`: Unique identifier for this protocol (e.g., 0x00420001)
/// - `schema_version`: Version for evolution tracking (increment on breaking changes)
///
/// ## Optional Metadata Fields
///
/// - `sequence`: Message ordering (for OrderedSubscriber and actor mailboxes)
/// - `destination`: Routing hint (Broadcast, Unicast to actor, Partition)
/// - `correlation_id`: Request/reply correlation
/// - `trace_id`: Distributed tracing (track messages across system boundaries)
///
/// These fields are `Option<T>` for zero cost when unused.
pub struct Envelope {
    /// Schema identifier (unique per protocol)
    ///
    /// Used to detect incompatible protocols when connecting nodes.
    /// Pick a random u32 and document it in your contracts.yaml
    pub schema_id: u32,

    /// Schema version (increment on breaking changes)
    ///
    /// Used for protocol evolution and version negotiation.
    /// Decoders can skip unknown fields within compatible version range.
    pub schema_version: u16,

    /// Message type ID (within this schema)
    pub type_id: u16,

    /// Topic this message belongs to (Arc for zero-cost cloning)
    pub topic: Arc<str>,

    /// Optional sequence number for ordered delivery
    ///
    /// When `Some(n)`, subscribers can use this to ensure FIFO ordering.
    /// When `None`, messages are delivered as-received (default).
    pub sequence: Option<u64>,

    /// Optional routing hint
    ///
    /// - `None` or `Some(Destination::Broadcast)`: Standard pub/sub (all subscribers)
    /// - `Some(Destination::Unicast(actor_id))`: Actor mailbox routing
    /// - `Some(Destination::Partition(hash))`: Partition-based routing
    pub destination: Option<Destination>,

    /// Optional correlation ID for request/reply
    ///
    /// Used to match responses to requests in async request/reply patterns.
    /// When `None`, this is a one-way message.
    pub correlation_id: Option<CorrelationId>,

    /// Optional trace ID for distributed tracing
    ///
    /// Used to track a message as it flows through the system.
    /// All messages derived from the same user action should share the same TraceId.
    /// When `None`, tracing is disabled.
    pub trace_id: Option<TraceId>,

    /// Type-erased payload (Arc for zero-copy sharing)
    payload: Arc<dyn Any + Send + Sync>,
}

impl std::fmt::Debug for Envelope {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Envelope")
            .field("schema_id", &format_args!("0x{:08X}", self.schema_id))
            .field("schema_version", &self.schema_version)
            .field("type_id", &self.type_id)
            .field("topic", &self.topic)
            .field("sequence", &self.sequence)
            .field("trace_id", &self.trace_id)
            .field("payload", &"<opaque>")
            .finish()
    }
}

impl Envelope {
    /// Create a new envelope from a message (no metadata)
    pub fn new<M: Message>(msg: M) -> Self {
        Self {
            schema_id: DEFAULT_SCHEMA_ID,
            schema_version: DEFAULT_SCHEMA_VERSION,
            type_id: M::TYPE_ID,
            topic: Arc::from(M::TOPIC),
            sequence: None,
            destination: None,
            correlation_id: None,
            trace_id: None,
            payload: Arc::new(msg) as Arc<dyn Any + Send + Sync>,
        }
    }

    /// Create a new envelope with a sequence number (for ordered delivery)
    pub fn with_sequence<M: Message>(msg: M, sequence: u64) -> Self {
        Self {
            schema_id: DEFAULT_SCHEMA_ID,
            schema_version: DEFAULT_SCHEMA_VERSION,
            type_id: M::TYPE_ID,
            topic: Arc::from(M::TOPIC),
            sequence: Some(sequence),
            destination: None,
            correlation_id: None,
            trace_id: None,
            payload: Arc::new(msg) as Arc<dyn Any + Send + Sync>,
        }
    }

    /// Create envelope with destination (for actor routing)
    pub fn with_destination<M: Message>(msg: M, destination: Destination) -> Self {
        Self {
            schema_id: DEFAULT_SCHEMA_ID,
            schema_version: DEFAULT_SCHEMA_VERSION,
            type_id: M::TYPE_ID,
            topic: Arc::from(M::TOPIC),
            sequence: None,
            destination: Some(destination),
            correlation_id: None,
            trace_id: None,
            payload: Arc::new(msg) as Arc<dyn Any + Send + Sync>,
        }
    }

    /// Create envelope with correlation ID (for request/reply)
    pub fn with_correlation<M: Message>(msg: M, correlation_id: CorrelationId) -> Self {
        Self {
            schema_id: DEFAULT_SCHEMA_ID,
            schema_version: DEFAULT_SCHEMA_VERSION,
            type_id: M::TYPE_ID,
            topic: Arc::from(M::TOPIC),
            sequence: None,
            destination: None,
            correlation_id: Some(correlation_id),
            trace_id: None,
            payload: Arc::new(msg) as Arc<dyn Any + Send + Sync>,
        }
    }

    /// Create envelope with trace ID (for distributed tracing)
    pub fn with_trace<M: Message>(msg: M, trace_id: TraceId) -> Self {
        Self {
            schema_id: DEFAULT_SCHEMA_ID,
            schema_version: DEFAULT_SCHEMA_VERSION,
            type_id: M::TYPE_ID,
            topic: Arc::from(M::TOPIC),
            sequence: None,
            destination: None,
            correlation_id: None,
            trace_id: Some(trace_id),
            payload: Arc::new(msg) as Arc<dyn Any + Send + Sync>,
        }
    }

    /// Create envelope with all metadata (full control)
    pub fn with_metadata<M: Message>(
        msg: M,
        sequence: Option<u64>,
        destination: Option<Destination>,
        correlation_id: Option<CorrelationId>,
        trace_id: Option<TraceId>,
    ) -> Self {
        Self {
            schema_id: DEFAULT_SCHEMA_ID,
            schema_version: DEFAULT_SCHEMA_VERSION,
            type_id: M::TYPE_ID,
            topic: Arc::from(M::TOPIC),
            sequence,
            destination,
            correlation_id,
            trace_id,
            payload: Arc::new(msg) as Arc<dyn Any + Send + Sync>,
        }
    }

    /// Create an envelope from raw components (for internal transport layer use)
    ///
    /// **Note**: This is a low-level API used by transport implementations.
    /// Most users should use `Envelope::new()` instead.
    #[doc(hidden)]
    pub fn from_raw(type_id: u16, topic: Arc<str>, payload: Arc<dyn Any + Send + Sync>) -> Self {
        Self {
            schema_id: DEFAULT_SCHEMA_ID,
            schema_version: DEFAULT_SCHEMA_VERSION,
            type_id,
            topic,
            sequence: None,
            destination: None,
            correlation_id: None,
            trace_id: None,
            payload,
        }
    }

    /// Create an envelope from raw components with all metadata
    #[doc(hidden)]
    pub fn from_raw_with_metadata(
        type_id: u16,
        topic: Arc<str>,
        sequence: Option<u64>,
        destination: Option<Destination>,
        correlation_id: Option<CorrelationId>,
        trace_id: Option<TraceId>,
        payload: Arc<dyn Any + Send + Sync>,
    ) -> Self {
        Self {
            schema_id: DEFAULT_SCHEMA_ID,
            schema_version: DEFAULT_SCHEMA_VERSION,
            type_id,
            topic,
            sequence,
            destination,
            correlation_id,
            trace_id,
            payload,
        }
    }

    /// Attempt to downcast the envelope to a concrete message type
    pub fn downcast<M: Message>(self) -> Result<Arc<M>, EnvelopeError> {
        // Check type ID first
        if self.type_id != M::TYPE_ID {
            return Err(EnvelopeError::TypeMismatch {
                expected: M::TYPE_ID,
                got: self.type_id,
            });
        }

        // Attempt downcast
        self.payload
            .downcast::<M>()
            .map_err(|_| EnvelopeError::DowncastFailed)
    }

    /// Check if this envelope matches a specific message type
    pub fn is<M: Message>(&self) -> bool {
        self.type_id == M::TYPE_ID
    }

    /// Downcast the envelope payload to any type (for internal transport use)
    pub fn downcast_any<T: Any + Send + Sync>(self) -> Result<Arc<T>, EnvelopeError> {
        self.payload
            .downcast::<T>()
            .map_err(|_| EnvelopeError::DowncastFailed)
    }
}

impl Clone for Envelope {
    fn clone(&self) -> Self {
        Self {
            schema_id: self.schema_id,
            schema_version: self.schema_version,
            type_id: self.type_id,
            topic: self.topic.clone(),
            sequence: self.sequence,
            destination: self.destination,
            correlation_id: self.correlation_id,
            trace_id: self.trace_id,
            payload: Arc::clone(&self.payload),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::impl_message;
    use zerocopy::{FromBytes, FromZeros, Immutable, IntoBytes};

    #[derive(Debug, Clone, Copy, PartialEq, IntoBytes, FromBytes, FromZeros, Immutable)]
    #[repr(C)]
    struct TestMessage {
        value: u64,
    }

    impl_message!(TestMessage, 99, "test");

    #[test]
    fn test_envelope_creation() {
        let msg = TestMessage { value: 42 };
        let envelope = Envelope::new(msg);

        assert_eq!(envelope.type_id, 99);
        assert_eq!(envelope.topic.as_ref(), "test");
        assert!(envelope.is::<TestMessage>());
    }

    #[test]
    fn test_envelope_downcast_success() {
        let msg = TestMessage { value: 42 };
        let envelope = Envelope::new(msg.clone());

        let downcasted = envelope.downcast::<TestMessage>().unwrap();
        assert_eq!(downcasted.value, 42);
    }

    #[test]
    fn test_envelope_downcast_type_mismatch() {
        #[derive(Debug, Clone, Copy, IntoBytes, FromBytes, FromZeros, Immutable)]
        #[repr(C)]
        struct OtherMessage {
            data: u64,
        }

        impl_message!(OtherMessage, 100, "other");

        let msg = TestMessage { value: 42 };
        let envelope = Envelope::new(msg);

        let result = envelope.downcast::<OtherMessage>();
        assert!(matches!(
            result,
            Err(EnvelopeError::TypeMismatch {
                expected: 100,
                got: 99
            })
        ));
    }

    #[test]
    fn test_envelope_clone() {
        let msg = TestMessage { value: 42 };
        let envelope = Envelope::new(msg);

        let cloned = envelope.clone();
        assert_eq!(cloned.type_id, 99);
        assert_eq!(cloned.topic.as_ref(), "test");

        // Both should be able to downcast
        let _ = cloned.downcast::<TestMessage>().unwrap();
    }
}
